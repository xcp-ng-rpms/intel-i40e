From 0de15cd581ff61100ae0ea39eb547d578f214ad3 Mon Sep 17 00:00:00 2001
From: Stephen Cheng <stephen.cheng@citrix.com>
Date: Mon, 1 Dec 2025 12:53:27 +0800
Subject: [PATCH] Fix PTP work queue corruption issue

Fix two critical race conditions in PTP functionality:

1. Work queue corruption: Move INIT_WORK() from i40e_ptp_set_timestamp_mode()
   to i40e_probe() to prevent multiple initialization of the same work
   structure while work is queued, which caused kernel crashes.

2. Move i40e_ptp_stop() to after i40e_vsi_release() in i40e_remove().
   This ensures interrupts are fully freed before PTP cleanup,
   preventing any ISR from scheduling work after the clock is freed.

Signed-off-by: Stephen Cheng <stephen.cheng@citrix.com>
---
 src/i40e.h      |  1 +
 src/i40e_main.c | 16 +++++++++-------
 src/i40e_ptp.c  | 21 +++++++++++----------
 3 files changed, 21 insertions(+), 17 deletions(-)

diff --git a/src/i40e.h b/src/i40e.h
index fe5f03b..319589c 100644
--- a/src/i40e.h
+++ b/src/i40e.h
@@ -1468,6 +1468,7 @@ void i40e_ptp_save_hw_time(struct i40e_pf *pf);
 void i40e_ptp_restore_hw_time(struct i40e_pf *pf);
 void i40e_ptp_init(struct i40e_pf *pf);
 void i40e_ptp_stop(struct i40e_pf *pf);
+void i40e_ptp_extts0_work(struct work_struct *work);
 int i40e_ptp_alloc_pins(struct i40e_pf *pf);
 #endif /* HAVE_PTP_1588_CLOCK */
 u8 i40e_pf_get_num_tc(struct i40e_pf *pf);
diff --git a/src/i40e_main.c b/src/i40e_main.c
index ede3885..8071be4 100644
--- a/src/i40e_main.c
+++ b/src/i40e_main.c
@@ -17857,6 +17857,7 @@ static int i40e_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		pf->hw_features |= I40E_HW_PORT_ID_VALID;
 #ifdef HAVE_PTP_1588_CLOCK
 	i40e_ptp_alloc_pins(pf);
+	INIT_WORK(&pf->ptp_extts0_work, i40e_ptp_extts0_work);
 #endif /* HAVE_PTP_1588_CLOCK */
 
 #ifdef HAVE_PCI_ERS
@@ -18298,13 +18299,6 @@ static void i40e_remove(struct pci_dev *pdev)
 	int i;
 
 	i40e_dbg_pf_exit(pf);
-#ifdef HAVE_PTP_1588_CLOCK
-	i40e_ptp_stop(pf);
-
-	/* Disable RSS in hw */
-	i40e_write_rx_ctl(hw, I40E_PFQF_HENA(0), 0);
-	i40e_write_rx_ctl(hw, I40E_PFQF_HENA(1), 0);
-#endif /* HAVE_PTP_1588_CLOCK */
 
 	/* Grab __I40E_RESET_RECOVERY_PENDING and set __I40E_IN_REMOVE
 	 * flags, once they are set, i40e_rebuild should not be called as
@@ -18376,6 +18370,14 @@ static void i40e_remove(struct pci_dev *pdev)
 			pf->vsi[i] = NULL;
 		}
 
+#ifdef HAVE_PTP_1588_CLOCK
+	i40e_ptp_stop(pf);
+
+	/* Disable RSS in hw */
+	i40e_write_rx_ctl(hw, I40E_PFQF_HENA(0), 0);
+	i40e_write_rx_ctl(hw, I40E_PFQF_HENA(1), 0);
+#endif /* HAVE_PTP_1588_CLOCK */
+
 	i40e_cloud_filter_exit(pf);
 
 	/* Restore FLU mask value */
diff --git a/src/i40e_ptp.c b/src/i40e_ptp.c
index db9f56e..17acb08 100644
--- a/src/i40e_ptp.c
+++ b/src/i40e_ptp.c
@@ -165,7 +165,7 @@ static int i40e_ptp_set_pins(struct i40e_pf *pf,
  *
  * Service for PTP external clock event
  **/
-static void i40e_ptp_extts0_work(struct work_struct *work)
+void i40e_ptp_extts0_work(struct work_struct *work)
 {
 	struct i40e_pf *pf = container_of(work, struct i40e_pf,
 					  ptp_extts0_work);
@@ -1370,8 +1370,6 @@ static int i40e_ptp_set_timestamp_mode(struct i40e_pf *pf,
 	regval |= 1 << I40E_PRTTSYN_CTL0_EVENT_INT_ENA_SHIFT;
 	wr32(hw, I40E_PRTTSYN_CTL0, regval);
 
-	INIT_WORK(&pf->ptp_extts0_work, i40e_ptp_extts0_work);
-
 	/* Reserved for future extensions. */
 	if (config->flags)
 		return -EINVAL;
@@ -1843,6 +1841,8 @@ void i40e_ptp_init(struct i40e_pf *pf)
 	} else {
 		u32 regval;
 
+		cancel_work_sync(&pf->ptp_extts0_work);
+
 		if (pf->hw.debug_mask & I40E_DEBUG_LAN)
 			dev_info(&pf->pdev->dev, "PHC enabled.\n");
 		pf->flags |= I40E_FLAG_PTP;
@@ -1888,6 +1888,13 @@ void i40e_ptp_stop(struct i40e_pf *pf)
 	pf->ptp_tx = false;
 	pf->ptp_rx = false;
 
+	/* Disable interrupts */
+	regval = rd32(hw, I40E_PRTTSYN_CTL0);
+	regval &= ~I40E_PRTTSYN_CTL0_EVENT_INT_ENA_MASK;
+	wr32(hw, I40E_PRTTSYN_CTL0, regval);
+
+	cancel_work_sync(&pf->ptp_extts0_work);
+
 	if (pf->ptp_tx_skb) {
 		struct sk_buff *skb = pf->ptp_tx_skb;
 
@@ -1899,8 +1906,7 @@ void i40e_ptp_stop(struct i40e_pf *pf)
 	if (pf->ptp_clock) {
 		ptp_clock_unregister(pf->ptp_clock);
 		pf->ptp_clock = NULL;
-		dev_info(&pf->pdev->dev, "removed PHC from %s.\n",
-			 pf->vsi[pf->lan_vsi]->netdev->name);
+		dev_info(&pf->pdev->dev, "removed PHC\n");
 	}
 
 	if (i40e_is_ptp_pin_dev(&pf->hw)) {
@@ -1913,11 +1919,6 @@ void i40e_ptp_stop(struct i40e_pf *pf)
 	regval &= ~I40E_PRTTSYN_AUX_0_PTPFLAG_MASK;
 	wr32(hw, I40E_PRTTSYN_AUX_0(0), regval);
 
-	/* Disable interrupts */
-	regval = rd32(hw, I40E_PRTTSYN_CTL0);
-	regval &= ~I40E_PRTTSYN_CTL0_EVENT_INT_ENA_MASK;
-	wr32(hw, I40E_PRTTSYN_CTL0, regval);
-
 	i40e_ptp_free_pins(pf);
 }
 #endif /* HAVE_PTP_1588_CLOCK */
-- 
2.48.1

